#include "Display.h"
#include "TouchMenuLib.h"
#include <string>
#include <vector>
#include <cctype> // For std::isdigit
#include <stdexcept> // For std::invalid_argument and std::out_of_range
#include <cstdlib>
#include <algorithm>

void Display::drawItem (uint16_t x, uint16_t y, Item* item, const Color& color) {
    item->draw(x, y, color);
}

// This code is generated by ChatGPT and lightly overedited by me 

Color Display::parseColor(const std::string& colorStr, const Color& color) {
    std::string modifiedColorStr = colorStr; // Kopie von colorStr erstellen

    if (modifiedColorStr.find(',') != std::string::npos) {
        // RGB-Werte im Format "r,g,b"
        size_t pos = 0;
        std::vector<std::string> rgbValues;
        while ((pos = modifiedColorStr.find(',')) != std::string::npos) {
            rgbValues.push_back(modifiedColorStr.substr(0, pos));
            modifiedColorStr.erase(0, pos + 1);
        }
        rgbValues.push_back(modifiedColorStr);

        if (rgbValues.size() == 3) {
            uint8_t r = std::atoi(rgbValues[0].c_str());
            uint8_t g = std::atoi(rgbValues[1].c_str());
            uint8_t b = std::atoi(rgbValues[2].c_str());
            return Color(r, g, b);
        }
    } else {
        if (modifiedColorStr == "Yellow") return Color(255, 255, 0);
        if (modifiedColorStr == "Gray") return Color(50, 50, 50);
    }

    return color;
}

std::string Display::processText(const std::string& input) {
    std::string result = input;

    // Ersetze "__" zuerst durch ein nicht benutztes Zeichen ("#@@$~")
    size_t doubleUnderscorePos;
    while ((doubleUnderscorePos = result.find("__")) != std::string::npos) {
        result.replace(doubleUnderscorePos, 2, "#@@$~");
    }

    // Ersetze alle verbleibenden einzelnen Unterstriche am Ende durch Leerzeichen
    size_t underscorePos;
    while ((underscorePos = result.find("_")) != std::string::npos) {
        result.replace(underscorePos, 1, " ");
    }

    // Wandel "#@@$~" wieder in "_" um
    size_t hashPos;
    while ((hashPos = result.find("#@@$~")) != std::string::npos) {
        result.replace(hashPos, 5, "_");
    }

    return result;
}


double Display::parseSize(const std::string& sizeStr) {
    try {
        double parsedSize = std::atof(sizeStr.c_str());
        return parsedSize;
    } catch (const std::invalid_argument& e) {
        // Fehler bei der Konvertierung
    } catch (const std::out_of_range& e) {
        // Wert außerhalb des darstellbaren Bereichs
    }
    
    // Standard-Rückgabewert im Fehlerfall
    return 0.0;
}

Item* Display::createItem(const std::string str) {
    return createItem(str, Color(0,0,0) + Color(200, 200, 200));
}

Item* Display::createItem(const std::string str, const Color& color) {
    std::string input = str;
    std::string type, name, color1Str, color2Str, border1Str, border2Str, sizeStr, heightStr, widthStr;
    double size = 0.0;
    int width, height;

    std::vector<std::string> tokens;
    size_t pos = 0;
    while ((pos = input.find(' ')) != std::string::npos) {
        tokens.push_back(input.substr(0, pos));
        input.erase(0, pos + 1);
    }
    tokens.push_back(input);

    if (!tokens.empty()) {
        if (tokens[0].find(':') == std::string::npos) {
            // Kein ':' in den ersten 5 Zeichen, also Typ "text" annehmen
            type = "text";
            name = str;
        } else {
            for (const std::string& token : tokens) {
                size_t colonPos = token.find(':');
                if (colonPos != std::string::npos) {
                    std::string key = token.substr(0, colonPos);
                    std::string value = token.substr(colonPos + 1);

                    if (key == "icon" || key == "file" || key == "symb" || key == "text") {
                        type = key;
                        if (key == "text") name = processText(value);
                        else name = value;
                    } else if (key == "color") {
                        color1Str = value;
                    } else if (key == "colorOff") {
                        color2Str = value;
                    } else if (key == "border") {
                        border1Str = value;
                    } else if (key == "borderOff") {
                        border2Str = value;
                    } else if (key == "size") {
                        sizeStr = value;
                    } else if (key == "height") {
                        heightStr = value;
                    } else if (key == "width") {
                        widthStr = value;
                    }
                }
            }
        }
    }

    Color nColor = Color(color)
        .setPrimaryColor(parseColor(color1Str, color))
        .setItemColor(parseColor(border1Str, color.getItemColor()))
        .setSecondaryColor(parseColor(color2Str, color.getSecondaryColor()))
        .setSecondaryItemColor(parseColor(border2Str, color.getSecondaryColor().getItemColor()));

    size = parseSize(sizeStr);
    width = parseSize(widthStr);
    height = parseSize(widthStr);

    LOGGER_PATTERN("Erstelle ITEM: _ der Art _", type.c_str(), name.c_str());

    if (name == "") return new Text("No Name", this);
    else if (type == "") return new Text("No type", this);

    else if (type == "text") 
        return new Text(name.c_str(), this, nColor, size);

    else if (type=="icon") {
        if (name == "") return new Text("ERR 1", this, nColor, (uint8_t) size);
        auto* icon = Icon::create(name, color, this);
        if (icon) return icon;
        else return new Text("ERR 2", this);

    } else if (type == "file") {

    } else if (type == "symb") {
        return new Symbol(name, this, nColor, (uint16_t) height, (uint16_t) width);
    }
    
    return new Text("ERR", this);
}